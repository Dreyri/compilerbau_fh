PARSER_BEGIN(Parser)
import java.util.*;

public class Parser {
    public static SymTable symTable = new SymTable();

    public static void main(String[] args)
    {
        try {
	    Expr res = new Parser(new java.io.StringReader(args[0])).S();
            System.out.println(symTable);
	    System.out.println(res);
	}
	catch(Throwable e)
	{
	    System.out.println("Syntax error: " + e.getMessage());
	}
    }
}

abstract class Expr {}
class Num extends Expr {
    int value;

    Num(int v) {value = v;}
    public String toString() { return value + ""; }
}

class BinaryExpr extends Expr {
    String op;
    Expr left, right;

    BinaryExpr(String o, Expr lhs, Expr rhs) {op = o; left = lhs; right = rhs; }
    public String toString() { return left.toString() + " " + right.toString() + " " + op; }
}

enum TAG {
    CONST,
    VAR
}

class Symbol {
    String value;
    TAG tag;
  
    Symbol(String val, TAG t) {
        value = val;
        tag = t;
    }

    public String getVal() {
        return value;
    }

    public String toString() {
        return "(" + value + ", " + tag + ")";
    }
}

class SymTable  {
    Hashtable symbols = new Hashtable();

    void addConstant(String id, String val) {
        symbols.put(id, new Symbol(val, TAG.CONST));
    }

    void addVariable(String id, String val) {
        if(val == "")
            val = "0";

        symbols.put(id, new Symbol(val, TAG.VAR));
    }
  
    Symbol getSymbol(String id) throws ParseException {
        if(!symbols.containsKey(id)) 
             throw new ParseException("symbol " + id + " undefined");
       
         return (Symbol)symbols.get(id);
    }    

    public String toString() {
         return symbols.toString();
    } 
}

PARSER_END(Parser)

SKIP: {
    " "
  | "\t"
  | "\r"
  | "\n"
}

TOKEN: {
    "(" | ")" | "int" | "final" | "=" | ";"
  | <OP0: "*" | "/">
  | <OP1: "+" | "-">
  | <NUM: "0" | (["1"-"9"](["0"-"9"])*)>
  | <#DIGIT: ["0"-"9"]>
  | <#LLETTER: ["a"-"z"]>
  | <#ULETTER: ["A"-"Z"]>
  | <#LETTER: <LLETTER> | <ULETTER>>
  | <#ALPHANUM: <DIGIT> | <LETTER>>
  | <IDENT: <LLETTER> (<ALPHANUM>)*>
}

Expr S():
{Expr e;}
{
    (constDecl())?
    (varDecl())?
    (e=E() {return e;})? <EOF>
}

void constDecl():
{}
{
    "final" "int" constAssign() (constList())? ";"
}

void constAssign():
{
   Token id = null;
   Token num = null;
}
{
   id = <IDENT> "=" num = <NUM> 
   {
       symTable.addConstant(id.image, num.image);      
   }
}

void constList():
{}
{
    "," constAssign() (constList())?
}

void varDecl():
{
   String num = "";
   Token id = null;
}
{
   "int" id = <IDENT> (num = varAssign() 
    { 
        symTable.addVariable(id.image, num); 
    })?
    {
        symTable.addVariable(id.image, "");
    } (varList())? ";"
}

String varAssign():
{
   Token num = null;
}
{
   "=" num = <NUM> 
   { 
      return num.image; 
   } 
}

void varList():
{
    String num = "";
    Token id = null;
}
{
    "," id = <IDENT> (num = varAssign()
    {
        symTable.addVariable(id.image, num);
    })? 
    {
        symTable.addVariable(id.image, "");
    } (varList())?
}

Expr E():
{Expr e1; Expr e2; Token o;}
{
    e1=T() (o=<OP1> e2=T() {e1 = new BinaryExpr(o.image, e1, e2);})* {return e1;}
}

Expr T():
{Expr e1; Expr e2; Token o;}
{
    e1=F() (o=<OP0> e2=F() {e1 = new BinaryExpr(o.image, e1, e2);})* {return e1;}
}

Expr F():
{Expr e; Token n;}
{
    n=<NUM> {return new Num(Integer.parseInt(n.image));}
  | n=<IDENT> {return new Num(Integer.parseInt(symTable.getSymbol(n.image).getVal()));}
  | "(" e=E() ")" {return e;}
}
